## 4.아키텍처
### MySQL 스레딩 구조
- InnoDB를 사용할 경우, 포그라운드 스레드와 백그라운드 스레드를 사용한다.
- 포그라운드 스레드는 클라이언트가 요청하는 쿼리 문장을 처리한다.
- 백그라운드 스레드는 버퍼 병합, 로그 디스크 기록, 버퍼로 읽어오기, 잠금이나 데드락 모니터링등을 수행한다.

#### 백그라운드 스레드
- 쓰기 스레드는 많은 작업을 백그라운드로 처리한다.
- 일반적인 내장 디스크를 사용할 때는 2~4 정도, DAS나 SAN과 같은 스토리지는 최적으로 사용할만큼 충분히 하는 게 좋다.
- 대부분의 DBMS는 쓰기 작업을 버퍼링해 처리한다.
- InnoDB도 이렇게 처리하지만 MyISAM은 그렇지 않다.

### 메모리 할당 및 사용 구조
- MySQL에서 사용되는 메모리 공간은 글로벌 메모리 영역과 로컬 메모리 영역으로 구분할 수 있다.

#### 글로벌 메모리 영역
- 모든 스레드에 의해 공유된다.
- 클라이언트 스레드 수와 무관하다.
- 대표적으로 다음과 같다.
  - 테이블 캐시
  - InnoDB 버퍼 풀
  - InnoDB 어댑티브 해시 인덱스
  - InnoDB 리두 로그 버퍼

#### 로컬 메모리 영역
- called 세션 메모리 영역 -> 클라이언트와 MySQL 서버와의 커넥션을 세션이라고 하기 때문에
- MySQL 서버상에 존재하는 클라이언트 스레드가 쿼리를 처리하는데 사용하는 메모리 영역이다.
- 클라이언트 스레드끼리 절대 공유하지 않는다.
- 각 쿼리의 용도별로 필요할 때만 할당하고 필요하지 않은 경우 할당을 하지 않는다.
- 대표적으로 다음과 같다.
  - 정렬 버퍼
  - 조인 버퍼
  - 바이너리 로그 캐시
  - 네트워크 버퍼

#### 플러그인 스토리지 엔진 모델
- 데이터 읽기 및 쓰기는 스토리지 엔진에서 처리되고 나머지 작업은 MySQL 엔진에서 처리된다.
- MySQL 엔진은 스토리지 엔진을 조정하기 위해 핸들러를 이용한다.
- 스토리지 엔진에게 데이터를 읽어오거나 저장하도록 명령하려면 반드시 핸드러를 통해야한다.
- GROUP BY나 ORDER BY 등 복잡한 처리는 MySQL 엔진의 쿼리 실행기에서 처리된다.

### 쿼리 실행 구조
- SQL 요청 -> 쿼리 파서 -> 전처리기 -> 옵티마이저 -> 쿼리 실행기 -> 스토리지 엔진 -> SQL 결과

#### 쿼리 파서
- 쿼리를 토큰으로 분리해 트리 형태의 구조로 만들어낸다.
- 기본 문법 오류는 이때 발견된다.

#### 전처리기
- 각 토큰을 테이블 이름이나 컬럼 이름 같은 개체에 매핑해 해당 객체의 존재 여부등을 확인한다.

#### 옵티마이저
- 쿼리를 저렴한 비용으로 가장 빠르게 처리하는 방법을 결정한다.
- 중요하고 영향 범위가 넓다.

#### 실행 엔진
- 만들어진 계획대로 각 핸들러에게 요청한다.
- 핸들러에게 받은 결과를 또 다른 핸들러 요청의 입력으로 연결한다.

#### 핸들러(스토리지 엔진)
- MySQL 서버 가장 밑단에서 실행 엔진의 요청에 따라 데이터를 디스크로 저장하고 디스크로부터 읽어 오는 역할을 담당한다.
- 결국 스토리지 엔진을 의미한다.

### 쿼리 캐시
- 쿼리 실행 결과를 메모리에 캐시해 읽기 성능에 큰 도움을 줬다.
- 하지만, 동시 처리 성능 저하와 많은 버그의 원인이 됐다.
- 그래서 8.0에서는 제거됐다.
