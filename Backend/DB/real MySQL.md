## 4.아키텍처
### MySQL 스레딩 구조
- InnoDB를 사용할 경우, 포그라운드 스레드와 백그라운드 스레드를 사용한다.
- 포그라운드 스레드는 클라이언트가 요청하는 쿼리 문장을 처리한다.
- 백그라운드 스레드는 버퍼 병합, 로그 디스크 기록, 버퍼로 읽어오기, 잠금이나 데드락 모니터링등을 수행한다.

#### 백그라운드 스레드
- 쓰기 스레드는 많은 작업을 백그라운드로 처리한다.
- 일반적인 내장 디스크를 사용할 때는 2~4 정도, DAS나 SAN과 같은 스토리지는 최적으로 사용할만큼 충분히 하는 게 좋다.
- 대부분의 DBMS는 쓰기 작업을 버퍼링해 처리한다.
- InnoDB도 이렇게 처리하지만 MyISAM은 그렇지 않다.

### 메모리 할당 및 사용 구조
- MySQL에서 사용되는 메모리 공간은 글로벌 메모리 영역과 로컬 메모리 영역으로 구분할 수 있다.

#### 글로벌 메모리 영역
- 모든 스레드에 의해 공유된다.
- 클라이언트 스레드 수와 무관하다.
- 대표적으로 다음과 같다.
  - 테이블 캐시
  - InnoDB 버퍼 풀
  - InnoDB 어댑티브 해시 인덱스
  - InnoDB 리두 로그 버퍼

#### 로컬 메모리 영역
- called 세션 메모리 영역 -> 클라이언트와 MySQL 서버와의 커넥션을 세션이라고 하기 때문에
- MySQL 서버상에 존재하는 클라이언트 스레드가 쿼리를 처리하는데 사용하는 메모리 영역이다.
- 클라이언트 스레드끼리 절대 공유하지 않는다.
- 각 쿼리의 용도별로 필요할 때만 할당하고 필요하지 않은 경우 할당을 하지 않는다.
- 대표적으로 다음과 같다.
  - 정렬 버퍼
  - 조인 버퍼
  - 바이너리 로그 캐시
  - 네트워크 버퍼

#### 플러그인 스토리지 엔진 모델
- 데이터 읽기 및 쓰기는 스토리지 엔진에서 처리되고 나머지 작업은 MySQL 엔진에서 처리된다.
- MySQL 엔진은 스토리지 엔진을 조정하기 위해 핸들러를 이용한다.
- 스토리지 엔진에게 데이터를 읽어오거나 저장하도록 명령하려면 반드시 핸드러를 통해야한다.
- GROUP BY나 ORDER BY 등 복잡한 처리는 MySQL 엔진의 쿼리 실행기에서 처리된다.

### 쿼리 실행 구조
- SQL 요청 -> 쿼리 파서 -> 전처리기 -> 옵티마이저 -> 쿼리 실행기 -> 스토리지 엔진 -> SQL 결과

#### 쿼리 파서
- 쿼리를 토큰으로 분리해 트리 형태의 구조로 만들어낸다.
- 기본 문법 오류는 이때 발견된다.

#### 전처리기
- 각 토큰을 테이블 이름이나 컬럼 이름 같은 개체에 매핑해 해당 객체의 존재 여부등을 확인한다.

#### 옵티마이저
- 쿼리를 저렴한 비용으로 가장 빠르게 처리하는 방법을 결정한다.
- 중요하고 영향 범위가 넓다.

#### 실행 엔진
- 만들어진 계획대로 각 핸들러에게 요청한다.
- 핸들러에게 받은 결과를 또 다른 핸들러 요청의 입력으로 연결한다.

#### 핸들러(스토리지 엔진)
- MySQL 서버 가장 밑단에서 실행 엔진의 요청에 따라 데이터를 디스크로 저장하고 디스크로부터 읽어 오는 역할을 담당한다.
- 결국 스토리지 엔진을 의미한다.

### 쿼리 캐시
- 쿼리 실행 결과를 메모리에 캐시해 읽기 성능에 큰 도움을 줬다.
- 하지만, 동시 처리 성능 저하와 많은 버그의 원인이 됐다.
- 그래서 8.0에서는 제거됐다.

### 스레드 풀
- 기본적으로 엔터프라이즈 에디션에서만 제공하고 커뮤니티 에디션은 지원하지 않는다.
- 대신 Percona Server에서 스레드 풀 기능을 제공한다.
- 플러그인 형태로 사용할 수 있다.
- 스레드 풀은 사용자의 요청을 처리하는 스레드 개수를 줄여 동시 처리되는 요청이 많더라도, CPU가 제한된 개수의 스레드 처리에만 집중하게 해 서버 자원의 소모를 줄이는 것이 목적이다.
- 설치한다고 성능이 두 배가 되고 그런 건 아니다.
- Percona Server의 스레드 풀은 기본적으로 CPU 코아 개수만큼 스레드 그룹을 생성한다.
- CPU 코어의 개수와 스레드 그룹 개수를 맞추는게 CPU 프로세스 친화도를 높이는 데 좋다.
- 스레드 풀은 스레드 그룹의 모든 스레드가 일을 처리하고 있다면, 새로운 작업 스레드를 추가할지 아니면 기존 작업 스레드가 처리를 완료할 때까지 기다릴지를 판단해야한다.
- 타이머 스레드는 스레드 그룹의 상태를 체크해서 `thread_pool_stall_limit` 시스템 변수에 정의된 밀리초만큼 끝내지 못하면 새로운 스레드를 생성한다.
- 하지만 전체 스레드 개수는 `thread_pool_max_threads`를 넘길 수 없다.
- 응답 시간에 민감한 서비스라면 `thread_pool_max_threads`을 적절히 낮춰야한다.

#### 트랜잭션 지원 메타데이터
- 테이블 구조 정보와 스토어드 프로그램 등의 정보를 데이터 딕셔너리 또는 메타데이터라고 한다.
- 8.0 이전 버전에서는 파일로 저장했지만 문제가 있어, 8.0 부터는 InnoDB의 테이블에 저장하도록 개선됐다.
- mysql DB는 `mysql.ibd`라는 이름의 테이블스페이스에 저장된다.
- 데이터 딕셔너리와 시스템 테이블이 모두 트랜잭션 기반의 InnoDB 스토리지 엔진에 저장되도록 개선됐다.
- 그래서 스키마 변경 작업 중간에 MySQL 서버가 비정상적으로 종료된다고 하더라도 스키마 변경이 완전히 성공하거나 완전히 실패로 정리된다.
- InnoDB 이외의 엔진은 SDI 파일을 이용한다.
- `*.ibd`를 `ibd2sdi`를 이용해 json으로 덤프할 수 있다.
