## 4.아키텍처
### MySQL 스레딩 구조
- InnoDB를 사용할 경우, 포그라운드 스레드와 백그라운드 스레드를 사용한다.
- 포그라운드 스레드는 클라이언트가 요청하는 쿼리 문장을 처리한다.
- 백그라운드 스레드는 버퍼 병합, 로그 디스크 기록, 버퍼로 읽어오기, 잠금이나 데드락 모니터링등을 수행한다.

#### 백그라운드 스레드
- 쓰기 스레드는 많은 작업을 백그라운드로 처리한다.
- 일반적인 내장 디스크를 사용할 때는 2~4 정도, DAS나 SAN과 같은 스토리지는 최적으로 사용할만큼 충분히 하는 게 좋다.
- 대부분의 DBMS는 쓰기 작업을 버퍼링해 처리한다.
- InnoDB도 이렇게 처리하지만 MyISAM은 그렇지 않다.

### 메모리 할당 및 사용 구조
- MySQL에서 사용되는 메모리 공간은 글로벌 메모리 영역과 로컬 메모리 영역으로 구분할 수 있다.

#### 글로벌 메모리 영역
- 모든 스레드에 의해 공유된다.
- 클라이언트 스레드 수와 무관하다.
- 대표적으로 다음과 같다.
  - 테이블 캐시
  - InnoDB 버퍼 풀
  - InnoDB 어댑티브 해시 인덱스
  - InnoDB 리두 로그 버퍼

#### 로컬 메모리 영역
- called 세션 메모리 영역 -> 클라이언트와 MySQL 서버와의 커넥션을 세션이라고 하기 때문에
- MySQL 서버상에 존재하는 클라이언트 스레드가 쿼리를 처리하는데 사용하는 메모리 영역이다.
- 클라이언트 스레드끼리 절대 공유하지 않는다.
- 각 쿼리의 용도별로 필요할 때만 할당하고 필요하지 않은 경우 할당을 하지 않는다.
- 대표적으로 다음과 같다.
  - 정렬 버퍼
  - 조인 버퍼
  - 바이너리 로그 캐시
  - 네트워크 버퍼

#### 플러그인 스토리지 엔진 모델
- 데이터 읽기 및 쓰기는 스토리지 엔진에서 처리되고 나머지 작업은 MySQL 엔진에서 처리된다.
- MySQL 엔진은 스토리지 엔진을 조정하기 위해 핸들러를 이용한다.
- 스토리지 엔진에게 데이터를 읽어오거나 저장하도록 명령하려면 반드시 핸드러를 통해야한다.
- GROUP BY나 ORDER BY 등 복잡한 처리는 MySQL 엔진의 쿼리 실행기에서 처리된다.

### 쿼리 실행 구조
- SQL 요청 -> 쿼리 파서 -> 전처리기 -> 옵티마이저 -> 쿼리 실행기 -> 스토리지 엔진 -> SQL 결과

#### 쿼리 파서
- 쿼리를 토큰으로 분리해 트리 형태의 구조로 만들어낸다.
- 기본 문법 오류는 이때 발견된다.

#### 전처리기
- 각 토큰을 테이블 이름이나 컬럼 이름 같은 개체에 매핑해 해당 객체의 존재 여부등을 확인한다.

#### 옵티마이저
- 쿼리를 저렴한 비용으로 가장 빠르게 처리하는 방법을 결정한다.
- 중요하고 영향 범위가 넓다.

#### 실행 엔진
- 만들어진 계획대로 각 핸들러에게 요청한다.
- 핸들러에게 받은 결과를 또 다른 핸들러 요청의 입력으로 연결한다.

#### 핸들러(스토리지 엔진)
- MySQL 서버 가장 밑단에서 실행 엔진의 요청에 따라 데이터를 디스크로 저장하고 디스크로부터 읽어 오는 역할을 담당한다.
- 결국 스토리지 엔진을 의미한다.

### 쿼리 캐시
- 쿼리 실행 결과를 메모리에 캐시해 읽기 성능에 큰 도움을 줬다.
- 하지만, 동시 처리 성능 저하와 많은 버그의 원인이 됐다.
- 그래서 8.0에서는 제거됐다.

### 스레드 풀
- 기본적으로 엔터프라이즈 에디션에서만 제공하고 커뮤니티 에디션은 지원하지 않는다.
- 대신 Percona Server에서 스레드 풀 기능을 제공한다.
- 플러그인 형태로 사용할 수 있다.
- 스레드 풀은 사용자의 요청을 처리하는 스레드 개수를 줄여 동시 처리되는 요청이 많더라도, CPU가 제한된 개수의 스레드 처리에만 집중하게 해 서버 자원의 소모를 줄이는 것이 목적이다.
- 설치한다고 성능이 두 배가 되고 그런 건 아니다.
- Percona Server의 스레드 풀은 기본적으로 CPU 코아 개수만큼 스레드 그룹을 생성한다.
- CPU 코어의 개수와 스레드 그룹 개수를 맞추는게 CPU 프로세스 친화도를 높이는 데 좋다.
- 스레드 풀은 스레드 그룹의 모든 스레드가 일을 처리하고 있다면, 새로운 작업 스레드를 추가할지 아니면 기존 작업 스레드가 처리를 완료할 때까지 기다릴지를 판단해야한다.
- 타이머 스레드는 스레드 그룹의 상태를 체크해서 `thread_pool_stall_limit` 시스템 변수에 정의된 밀리초만큼 끝내지 못하면 새로운 스레드를 생성한다.
- 하지만 전체 스레드 개수는 `thread_pool_max_threads`를 넘길 수 없다.
- 응답 시간에 민감한 서비스라면 `thread_pool_max_threads`을 적절히 낮춰야한다.

#### 트랜잭션 지원 메타데이터
- 테이블 구조 정보와 스토어드 프로그램 등의 정보를 데이터 딕셔너리 또는 메타데이터라고 한다.
- 8.0 이전 버전에서는 파일로 저장했지만 문제가 있어, 8.0 부터는 InnoDB의 테이블에 저장하도록 개선됐다.
- mysql DB는 `mysql.ibd`라는 이름의 테이블스페이스에 저장된다.
- 데이터 딕셔너리와 시스템 테이블이 모두 트랜잭션 기반의 InnoDB 스토리지 엔진에 저장되도록 개선됐다.
- 그래서 스키마 변경 작업 중간에 MySQL 서버가 비정상적으로 종료된다고 하더라도 스키마 변경이 완전히 성공하거나 완전히 실패로 정리된다.
- InnoDB 이외의 엔진은 SDI 파일을 이용한다.
- `*.ibd`를 `ibd2sdi`를 이용해 json으로 덤프할 수 있다.

## InnoDB 스토리지 엔진 아키텍처
- 스토리지 엔진 중 거의 유일하게 레코드 기반의 잠금을 제공한다.
- 그래서 높은 동시성 처리가 가능하고 안정적이며 성능이 뛰어나다.

### 프라이머리 키에 의한 클러스터링
- InnoDB의 모든 테이블은 기본적으로 프라이머리 키를 기준으로 클러스터링돼 저장된다.
- 프라이머리 키 값의 순서대로 디스크에 저장된다.
- 모든 세컨더리 인덱스는 레코드 주소 대신 프라이머리 키의 값을 논리적인 주소로 사용한다.
- 클러스터링 인덱스이기 때문에 프라이머리 키를 이용한 레인지 스캔은 상당히 빨리 처리될 수 있다.
- 쿼리 실행 계획에서 다른 보조 인덱스에 비해 비중이 높게 설정된다.

### 외래 키 지원
- InnoDB에서 외래 키는 부모 테이블과 자식 테이블 모두 해당 컬럼에 인덱스 생성이 필요하다.
- 변경 시에 부모 테이블이나 자식 테이블에 데이터가 있는지 체크하는 작업이 필요하므로 잠금이 여러 테이블로 전파된다.
- 따라서 데드락이 발생할 때가 많다.
- `foreign_key_checks` 시스템 변수를 `OFF`로 설정하면 외래 키 관계에 대한 체크 작업을 일시적으로 멈출 수 있다.
- 대량 레코드 적재나 삭제 등의 작업도 체크 없이 훨씬 빠르게 처리할 수 있다.
- 단, 작업 후 반드시 `ON`으로 다시 켜야한다.

### MVCC(Multi Version Concurrency Control)
- 레코드 레벨의 트랜잭션을 지원하는 DBMS가 제공하는 기능이다.
- 가장 큰 목적은 잠금을 사용하지 않는 일관된 읽기를 제공하는 데 있다.
- InnoDB는 undo log를 이용해 구현한다.
- 업데이트를 할 때, InnoDB 버퍼 풀에 새운 값을 업데이트하고 unndo log에 이전 값을 기록해둔다.
- 디스크인 데이터 파일에는 Write 스레드에 의해 새로운 값으로 업데이트 됐을 수도 있다.
- 다른 트랜잭션에서 해당 레코드를 조회하면 isolation level에 따라 다른 값을 조회한다.
- `READ_UNCOMMITED`인 경우 버퍼 풀의 데이터를 읽고 `READ_COMMITED` 이상은 언두에 있는 걸 읽는다.
- 이런 과정은 MVCC라고 한다.
- 트랜잭션이 길어지면 언두에서 오랫 동안 관리해야하기 때문에 시스템 테이블 스페이스의 공간이 많이 늘어날 수도 있다.
- 커밋을 수행하면 변경된 상태를 영구적으로 만든다.
- 롤백을 수행하면 언두 영역에 있는 걸 다시 버퍼 풀로 복구하고 언두 내용을 삭제한다.
- 커밋이 됐을 때 언두 영역의 백업 데이터가 바로 삭제되는 게 아니라 해당 트랜잭션이 더는 없을 때 삭제된다.

#### Non-Locking Consistent Read
- InnoDB 엔진은 MVCC 기술을 이용해 잠금을 걸지 않고 읽기 작업을 수행한다.
- 읽기 작업은 다른 트랜잭션이 가지고 있는 잠금을 기다리지 않고, 읽기 작업이 가능하다.
- isolation level이 `SERIALIZABLE` 미만이면 순수한 읽기(`SELECT`) 작업은 다른 트랜잭션의 변경 작업과 관계없이 잠금 대기없이 바로 실행된다.
- 트랜잭션이 오랫 동안 활성 상태라면 일관된 읽기를 위해 언두 로그를 삭제하지 못하고 계속 유지해야 하기 때문에 문제가 발생할 수 있다.

#### 자동 데드락 감지
- InnoDB 엔진은 데드락 감지 스레드를 가지고 있다.
- 데드락 감지 스레드가 주기적으로 잠금 대기 그래프를 검사해 교착 상태에 빠진 트랜잭션들을 찾아서 그 중 하나를 강제 종료한다.
- 먼저 종료할 스레드를 판단하는 기준은 트랜잭션의 언두 로그 양이다.
- 언두 로그 양이 적을 수록 종료 우선 순위가 높다.
- `innodb_table_locks` 시스템 변수를 활성화하면 InnoDB 스토리지 엔진 내부의 레코드 잠금뿐만 아니라 테이블 레벨의 잠금까지 감지할 수 있게 된다. 그래서 활성화하는 게 좋다.
- 동시 처리 스레드가 많아지만 데드락 감지 스레드가 느려진다.
- 느려지면 서비스 쿼리를 처리 중인 스레드는 대기하면서 서비스에 영향을 끼친다. 또한 데드락 감지 스레드가 더 많은 CPU 자원을 소모할 수도 있다.
- 이런 문제점을 위해 MySQL 서버는 `innodb_deadlock_detect` 시스템 변수를 제공한다.
- `OFF`로 설정하면 데드락 감지 스레드가 더는 작동하지 않는다.
- 이렇게 되면 데드락이 발생해도 무한정 대기할 수도 있다.
- `innodb_lock_wait_timeout` 시스템 변수를 활성화하면 데드락 상황에서 일정 시간이 지나면 자동으로 요청이 실패하고 에러 메세지를 반환한다.
- 잠금을 설정한 시간 동안 획득하지 못하면 쿼리를 실패하고 에러를 반환한다.
- 이 시간은 기본값인 50초 보다 낮은 시간으로 변경해서 사용할 것을 권장한다.

#### 자동화된 장애 복구
- InnoDB는 MySQL 서버가 시작될 때 완료되지 못한 트랜잭션이나 디스크에 일부만 기록된 데이터 페이지 등에 대해 복구 작업이 자동으로 진행된다.
- 자동으로 복구될 수 없는 손상이 있다면 자동 복구를 멈추고 MySQL 서버가 종료된다.
- 이때는 `MySQL` 서버의 설정 파일에 `innodb_force_recovery` 시스템 변수를 설정해서 MySQL 서버를 시작해야한다.

### InnoDB 버퍼 풀
- InnoDB 스토리지 엔진에서 가장 핵심적인 부분이다.
- 디스크의 데이터 파일이나 인덱스 정보를 메모리에 캐시해 두는 공간이다.
- 쓰기 작업을 지연시켜 일괄 작업으로 처리할 수 있게 해주는 버퍼 역할도 같이 한다.
- 버퍼 풀에 한 번에 모아서 처리하면 랜덤 디스크 작업의 횟수를 줄일 수 있다.

#### 버퍼 풀의 크기 설정
- 운영체제와 각 클라이언트 스레드가 사용할 메모리도 충분히 고려해서 설정해야한다.
- 레코드 버퍼는 클라이언트 세션에서 테이블의 레코드를 읽고 쓸 때 버퍼로 사용하는 공간인데, 종종 많은 메모리를 사용할 수도 있다.
- MySQL 서버가 사용하는 레코드 버퍼 공간은 별도로 설정할 수 없다.
- InnoDB 버퍼 풀의 크기를 적절히 작은 값으로 설정해서 조금씩 상황을 봐 가면서 증가시키는 방법이 최적이다.
- 처음으로 MySQL 서버를 준비한다면 다음의 방법을 권장한다.
  - 메모리 공간이 8GB 미만: 50% 정도만 InnoDB 버퍼 풀로 설정
  - 메모리 공간이 8GB 이상 50GB 미만: 50%에서 시작해서 조금씩 올림
  - 메모리 공간이 50GB 이상: 15GB ~ 30GB 정도를 나머지를 위해 남겨둠
- 버퍼 풀은 `innodb_buffer_pool_size` 시스템 변수로 크기를 동적으로 확장할 수 있다. 하지만 크리티컬하므로 부하가 많지 않을 때, 변경해야한다.
- 버퍼 풀은 128MB 청크 단위로 쪼개서 관되므로 이걸 단위 크기로 사용해야한다.
- `innodb_buffer_pool_instances` 시스템 변수를 이용해 버퍼 풀을 여러 개로 분리해서 관리할 수 있다.
- 각 버퍼 풀을 `buffer pool instance`라고 한다. 기본적으로 8개로 초기화된다.
- 메모리 공간이 40GB 이상이면 버퍼 풀 인스턴스당 5GB 정도가 되도록 설정하는 게 좋다.

#### 버퍼 풀의 구조
- InnoDB 스토리지 엔진은 버퍼 풀이라는 큰 메모리 공간을 페이지 크기(`innodb_page_size`)의 조각으로 쪼갠다.
- 데이터를 필요로 할 때 해당 데이터 페이지를 읽어서 각 조각에 저장한다.
- 버퍼 풀의 페이지 크기 조각을 관리하기 위해 InnoDB는 크게 LRU 리스트, 플러시 리스트, 프리 리스트라는 3개의 자료 구조를 관리한다.
  - 프리 리스트: 버퍼 풀에서 사용자 데이터로 채워지지 않은 비어 있는 페이지들의 목록이다. 사용자 쿼리가 새롭게 디스크의 데이터 페이지를 읽어와야 하는 경우 사용된다.
  - LRU 리스트: 엄밀하게는 LRU와 MRU 리스트가 결합된 형태이다.
  - 플러시 리스트: 디스크로 동기화되지 않은 데이터를 가진 데이터 페이지(더티 페이지)의 변경 시점 기준의 페이지 목록을 관리한다. 변경이 가해진 데이터 페이지는 플러시 리스트에 관리되고 특정 시점이 되면 디스크로 기록돼야한다.
- LRU 리스트를 관리하는 목적은 디스크로부터 한 번 읽어온 페이지를 버퍼 풀의 메모리에 유지해 디스크 읽기를 최소화하는 것이다.
- 한 번 읽힌 데이터 페이지가 이후 자주 사용된다면 데이터 페이지는 InnoDB 버퍼 풀의 MRU 영역에서 계속 살아남게 된다.
- 반면 거의 사용되지 않는다면 새롭게 디스크에서 읽히는 데이터 페이지들에 밀려서 LRU의 끝으로 밀려나 결국은 버퍼 풀에서 제거된다.

#### 버퍼 풀과 리두 로그
- 버퍼 풀과 리두 로그는 매우 밀접한 관계를 맺고 있다.
- 버퍼 풀은 크게 설정할 수록 쿼리 성능이 빨라진다.
- 하지만 버퍼 풀은 데이터 캐시와 쓰기 버퍼링 두 가지 용도가 있다.
- 버퍼 풀의 메모리 공간을 늘리는 것은 데이터 캐시 기능만 향상 시키는 것이다.
- 버퍼 풀은 디스크에서 읽은 상태에서 변경되지 않은 클린 페이지와 변경된 데이터를 가진 더티 페이지를 가지고 있다.
- 더티 페이지는 디스크와 메모리의 데이터 상태가 다르기 때문에 이후 디스크로 기록돼야 한다.
- 하지만 더티 페이지가 버퍼 풀에 계속 머무를 수 없다.
- 데이터 변경이 계속 발생하면 리두 로그 파일에 기록됐던 로그 엔트리는 새로운 로그 엔트리로 덮어 쓰인다.
- 그래서 InnoDB 스토리지 엔진은 전체 리두 로그 파일에서 재사용 가능한 공간과 재사용 불가능한 공간을 구분해서 관리해야한다.
  - active redo log: 재사용 불가능한 공간 
- 리두 로그 파일의 공간은 계속 순환돼 재사용되지만 기록될 때마다 로그 포지션은 계속 증가된다. 이를 LNS(Log Sequence Number)라고 한다.
- InnoDB 엔진은 주기적으로 체크포인트 이벤트를 발생시켜 리두 로그와 버퍼 풀의 더티 페이지를 디스크로 동기화한다.
- 체크포인트가 발생하면 체크포인트 LSN보다 작은 리두 로그 엔트와 관련된 더티 페이지는 모두 디스크로 동기화돼야한다.
- 버퍼 풀의 크기와 리두 로그 파일의 크기의 균형이 맞지 않는다면 결국 더티 페이지를 버퍼 풀에 많이 보관하지 못한다.
- 처음으로 리두 로그 파일의 크기를 선택하기 어렵다면 버퍼 풀의 크기가 100GB 이하의 MySQL 서버에서는 리두 로그 파일의 전체 크기를 5~10GB 수준으로 선택하고 필요할 때마다 조금씩 늘려가면서 최적값을 선택하는 것이 좋다.
- 버퍼 풀과 리두 로그 공간의 크기가 같을 필요는 없다. 버퍼 풀의 데이터 페이지를 통째로 가지고 있고 리두 로그는 변경분만 가지고 있기 때문에 더 적은 공간을 필요로 한다.
  - 예를 들면, 리두 로그 엔트리가 4KB이면 데이터 페이지는 16KB이다.

#### 버퍼 풀 플러시
- InnoDB 엔진은 성능 저하없이 더티 페이지들을 디스크에 동기화하기 위해 2개의 플러시 기능을 백그라운드로 실행한다.
  - 플러시 리스트 플러시
  - LRU 리스트 플러시
- 플러시 리스트 플러시
  - 리두 로그 공간의 재활용을 위해 주기적으로 오래된 리두 로그 엔트리가 사용하는 공간을 비워야한다.
  - 이를 위해서는 더티 페이지가 먼저 디스크로 동기화돼야한다.
  - 주기적으로 플러시 리스트 플러시 함수를 호출해서 플러시 리스트에서 오래전에 변경된 데이터 페이지 순서대로 디스크에 동기화하는 작업을 수행한다.
  - 더티 페이지를 디스크로 동기화하는 스레드를 클리너 스레드라고 한다.
  - 버퍼 풀 인스턴스 개수와 클리너 스레드 개수가 같은 게 이상적이다.
  - 더티 페이지 비율이 높을 수록 디스크 쓰기 작업을 버퍼링해 디스크 쓰기 작업 횟수를 줄일 수 있다.
  - 하지만 disk IO burst 현상이 발생할 가능성이 높아진다.
  - 어댑티브 플러시를 이용하면 설정한 % 이상일 때, 어댑티브 플러시 알고리즘을 작동하게 한다.
  - HDD라면 큰접한 페이지 중에서 더티 페이지가 있다면 함께 기록하는 `innodb_flush_neighbors`를 키는 게 좋지만, SDD라면 끄는 게 좋다.
- LRU 리스트 플러시
  - LRU 리스트에서 사용 빈도가 낮은 데이터 페이지들을 제거해 새로운 페이지들을 읽어올 공간을 만들어야한다.
  - 이를 위해 LRU 리스트 플러시 함수가 사용된다.

#### 버퍼 풀 상태 백업 및 복구
- 버퍼 풀은 쿼리의 성능에 매우 밀접하게 연결돼있다.
- 쿼리 요청이 빈번한 서버를 셧다운했다가 다시 시작하면 쿼리 처리 성능이 평상시보다 못하다.
- 평상시에는 버퍼 풀에 쿼리들이 사용할 데이터가 이미 준비돼있기 때문이다. 이런 상태를 워밍업이라고 표현한다.
- 셧다운 전에 버퍼 풀의 상태를 백업하고 재시작 후 버퍼 풀의 상태를 복구하면 워밍업을 할 수 있다.
- 버퍼 풀 백업 데이터는 크기가 매우 작지만, 버퍼 풀을 복구하는 과정은 데이터 페이지를 다시 디스크에서 읽어와 꽤 걸릴 수 있다.
- 버퍼 풀 복구 과정이 어느정도 진행됐는지도 확인할 수 있다.

### Double Write Buffer
- 리두 로그는 페이지의 변경된 내용만 기록한다.
- 더티 페이지를 디스크 파일로 플러시할 때 일부만 기록되는 문제가 발생하면 그 페이지의 내용은 복구할 수 없을 수도 있다.
- 페이지 일부만 기록되는 현상을 `partial-page` 또는 `torn-page`라고 한다.
- 더블 라이트 버퍼는 더티 페이지를 묶어서 한 번의 디스크 쓰기로 시스템 테이블스페이스의 DoubleWrite 버퍼에 기록한다.
- 그리고 InnoDB 엔진은 각 더티 페이지를 파일에 하나씩 랜덤으로 쓰기를 실행한다.
- 만약 페이지가 기록되는 중간에 OS가 비정상적으로 종료됐다면
- InnoDB 엔진은 시작할 때 항상 더블 라이트 버퍼의 내용과 데이터 파일의 페이지들을 모두 비교해 다른 내용의 페이지가 있으면 더블 라이트 버퍼의 내용을 데이터 파일의 페이지로 복사한다.
- 만약 데이터베이스 성능을 위해 InnoDB 리두 로그 동기화 설정을 1이 아닌 값으로 설정했다면 DoubleWrite도 비활성화 하는 것이 좋다.

### 언두 로그
- InnoDB 엔진은 트랜잭션과 격리 수준을 보장하기 위해 DML로 변경되기 이전 버전의 데이터를 별도로 백업한다.
- 이렇게 백업된 데이터를 언두 로그라고 한다.
  - 트랜잭션 보장: 트랜잭션 롤백시 언두 로그에 백업해둔 이전 버전의 데이터를 이용한다.
  - 격리 수준 보장: 데이터 변경 도중 다른 트랜잭션에서 데이터를 조회하면 트랜잭션 격리 수준에 맞게 읽게 해준다.

#### 언두 로그 레코드 모니터링
- 대용량 데이터를 처리하거나 트랜잭션이 오랜 시간 동안 실행될 때 언두 로그 양은 급격히 증가할 수 있다.
- 활성 상태 트랜잭션이 장시간 유지되는 것은 성능상 좋지 않다.
- 그래서 MySQL 서버의 언두 로그 레코드가 얼마나 되는지는 항상 모니터링하는 것이 좋다.
  - MySQL 8.0에서 사용 가능한 명령
    ```
    SELECT count FROM information_schema.innodb_metrics WHERE SUBSYSTEM='transaction' AND NAME='trx_resg_history_len';
    ```

#### 언두 테이블스페이스 관리
- 언두 로그가 저장되는 공간을 언두 테이블스페이스라고 한다.
- 하나의 언두 테이블스페이스는 1 ~ 128개 이하의 롤백 세크먼트를 가지며, 롤백 세그먼트는 1개 이상의 언두 슬롯을 가진다.
- 하나의 트랜잭션은 대략 2개 정도의 언두 슬롯을 필요로 한다고 가정하면 된다. 이걸 통해 최대 동시 처리 가능한 트랜잭션의 개수를 예측해볼수도 있다.
- 언두 로그 슬롯이 부족한 경우에는 트랜잭션을 시작할 수 없다.
- 언두 테이블스페이스의 불필요한 공간을 잘라내는 방법은 자동과 수동 두 가지 방법이 있다.
- 자동은 InnoDB 엔진의 퍼지 스레드가 주기적으로 깨어나 언두 로그 공간에서 불필요해진 언두 로그를 삭제하는 작업을 실행하는 것이다. 이 작업을 `언두 퍼지`라고 한다.

### 체인지 버퍼
- RDBMS에서 레코드가 변경하는 작업은 데이터 파일 뿐만 아니라 인덱스를 업데이트하는 작업도 필요하다.
- 하지만 인덱스를 업데이트하는 작업은 랜던 디스크 읽기가 필요해 인덱스가 많아지면 많은 자원을 소모하게 된다.
- 그래서 InnoDB는 변경할 인덱스 페이지가 버퍼 풀에 있으면 바로 업데이트를 수행하지만 그렇지 않으면 즉시 실행하지 않고 임시 공간에 저장한다.
- 이때 사용하는 임시 메모리 공간을 `체인지 버퍼`라고한다.
- 결과를 전달하기 전에 반드시 중복 여부를 체크해야하는 유니크 인덱스는 체인지 버퍼를 사용할 수 없다.
- 임시 저장된 인덱스 레코드 조각은 이후 백그라운드 스레드에 의해 병합된다.
- 이 스레드를 `체인지 버퍼 머지 스레드`라고한다.
- 체인지 버퍼에 저장할 값들을 `innodb_change_buffering`으로 조절할 수 있다.

### 리두 로그 및 로그 버퍼
- 리두 로그는 트랜잭션의 4가지 요소인 ACID 중에서 D(Durable)에 해당하는 영속성과 가장 밀접하게 연관돼있다.
- 리두 로그는 MySQL 서버가 비정상적으로 종료됐을 때, 데이터 파일에 기록되지 못한 데이터를 잃지 않게 해주는 안전 장치다.
- MySQL 서버를 포함한 대부분의 데이터 베이스 서버는 데이터 변경 내용을 로그로 먼저 기록한다. 그래서 리두 로그를 Write Ahead Log라고도 한다.
- 데이터 쓰기는 디스크 랜덤 액세스로 인해 큰 비용이 필요하다.
- 이로 인한 성능 저하를 막기 위해 쓰기 비용이 낮은 자료 구조를 가진 리두 로그를 가지고 있다.
- 리두 로그는 트랜잭션이 커밋되면 즉시 디스크에 기록하는 게 안전하지만 많은 부하를 유발한다.
- 그래서 InnoDB 엔진에서 리두 로그를 어느 주기로 디스크에 동기화할지를 결정하는 `innodb_flush_log_at_trx_commit` 시스템 변수를 제공한다.
- 해당 설정에 따라 커밋한 트랜잭션의 데이터가 사라질 수도 그렇지 않을 수도 있다.
- 리두 로그 파일의 전체 크기가 InnoDB 버퍼 풀의 크기에 맞게 적절히 선택돼야 InnoDB 스토리지 엔진이 적절히 변경된 내용을 버퍼 풀에 모았다가 한 번에 디스크에 기록할 수 있다.
- 변경 작업이 매우 많은 서버는 ACID 속성을 보장하는 수준에서 버퍼링하는 게 좋다. 이런 리두 로그 버퍼링에 사용되는 공간이 로그 버퍼다.

#### 리두 로그 아카이빙
- 리두 로그 아카이빙은 로그 파일이 로테이션될 때 복사되는 게 아니라 리두 로그 파일에 로그 엔트리가 추가될 때 함께 기록되는 방식을 사용하고 있다.

#### 리두 로그 활성화 및 비활성화
- InnoDB 엔진의 리두 로그는 MySQL 서버가 비정상적으로 종료됐을 때, 데이터 파일에 기록되지 못한 트랜잭션을 복구하기 위해 항상 활성화돼있다.
- MySQL 서버에서 트랜잭션이 커밋돼도 데이터 파일은 즉시 디스크로 동기화되지 않는 반면, 리두 로그는 항상 디스크로 기록된다.
- 물론 설정에 따라 바로 동기화되지 않을 수도 있다. 하지만 중요한 데이터는 바로 동기화되도록 설정하는 게 좋다.
- MySQL 8.0 버전부터는 수동으로 리두 로그를 활성화하거나 비활성화할 수 있게 됐다. 그래서 데이터를 복구하거나 대용량 데이터를 한번에 적재하는 경우 리두 로그를 비활성화해서 데이터 적재 시간을 단축시킬 수 있다.
  ```
  ALTER INSTANCE DISABLE INNODB REDO_LOG;
  
  // 리두 로그를 비활성화한 후 대량 데이터 적재를 실행
  LOAD DATA

  ALTER INSTANCE ENABLE INNODB REDO_LOG;
  ```

### 어댑티브 해시 인덱스
- 사용자가 수동으로 생성하는 인덱스가 아니라 InnoDB 스토리지 엔진에서 사용자가 자주 요청하는 데이터에 대해 자동으로 생성하는 인덱스이다.
- 데이터 베이스 서버가 얼마나 많은 일은 하느냐에 따라 B-Tree 인덱스에서 값을 찾는 과정이 느려질 수도 있고 빨라질 수도 있다.
- 몇 천 개의 스레드로 실행하면 CPU는 엄청난 프로세스 스케줄링을 하게 되고 자연스럽게 쿼리 성능은 떨어진다.
- 어댑티브 해시 인덱스는 이런 B-Tree 검색 시간을 줄여주기 위해 도입된 기능이다.
- InnoDB 스토리지 엔진은 자주 읽히는 데이터 페이지의 키 값을 이용해 해시 인덱스를 만든다.
- 필요할 때마다 해당 인덱스를 검색해서 레코드가 저장된 데이터 페이지를 바로 찾아갈 수 있다.
- 해시 인덱스는 인덱스 키 값과 해당 인덱스 키 값이 저장된 데이터 페이지 주소의 쌍으로 관리된다.
- 인덱스 키 값은 B-Tree 인덱스의 고유번화와 B-Tree 인덱스의 실제 키 값 조합으로 생성된다.
- 데이터 페이지 주소는 실제 키 값이 저장된 데이터 페이지의 메모리 주소를 가진다.
- 이는 InnoDB 버퍼 풀에 로딩된 페이지 주소를 의미한다. 그래서 어댑티브 해시 인덱스는 버퍼 풀에 올려진 데이터 페이지에 대해서만 관리된다. 버퍼 풀에서 해당 데이터 페이지가 없어지면 해당 페이지 정보도 사라진다.
- 하지만 모든 경우에 도움이 되는 것은 아니다.
- 도움이 되지 않는 경우는 다음과 같다.
  - 디스크 읽기가 많은 경우
  - 특정 패턴의 쿼리가 많은 경우(조인이나 LIKE 패턴 검색)
  - 매우 큰 데이터를 가진 테이블의 레코드를 폭넓게 읽는 경우
- 성능 향상에 도움이 되는 경우는 다음과 같다.
  - 디스크의 데이터가 InnoDB 버퍼 풀 크기와 비슷한 경우(디스크 읽기가 많지 않은 경우)
  - 동등 조건 검색(동등 비교와 IN 연산자)이 많은 경우
  - 쿼리가 데이터 중에서 일부 데이터에만 집중되는 경우
- 상당히 큰 메모리 공간을 사용할 수도 있다.
- 테이블을 삭제(`DROP`) 하거나 변경(`ALTER`)하려고 한다면 어댑티브 해시 인덱스에서 제거해야한다. 그래서 테이블이 삭제되거나 스키마가 변경되는 동안 많은 CPU 자원을 사용하고, 그만큼 데이터 베이스 서버의 처리 성능이 느려진다.
- 어댑티브 해시 인덱스는 기본적으로 활성화돼있다.
- 어댑티브 해시 인덱스가 도움이 되는지 판단할 방법은 MySQL 서버의 상태 값들을 살펴보는 것이다.

### InnoDB와 MyISAM, MEMORY 스토리지 엔진 비교
- MySQL 8.0에서는 MySQL 서버의 모든 기능이 InnoDB 스토리지 엔진 기반으로 재편됐다.
- MyISAM 스토리지 엔진만이 가지는 장점이 없는 상태이다.
- MEMORY 스토리지 엔진도 비슷하다.

## MySQL 로그 파일
### 에러 로그 파일
- MySQL이 실행되는 도중에 발생하는 에러나 경고 메세지가 출력되는 로그 파일이다.
- 쿼리 처리 도중 발생한 문제는 에러 로그를 자주 살펴봄으로써 알 수 있다.
- 자세한 케이스는 책을 참고한다.

### 제너럴 쿼리 로그 파일(제너럴 로그 파일, General log)
- MySQL 서버에서 실행되는 쿼리로 어떤 것들이 있는지 검토할 때 쿼리 로그를 활성화해서 사용하면 된다.
- 슬로우 쿼리 로그와는 조금 다르게, 실행 전 MySQL이 쿼리 요청을 받으면 바로 기록해 실행 중 에러가 발생해도 로그 파일에 기록된다.

### 슬로우 쿼리 로그
- 서비스 운영 중에 MySQL 서버의 전체적인 성능 저하를 검사할 때 슬로우 쿼리 로그가 많은 도움이 된다.
- 슬로우 쿼리 로그 파일에는 `long_query_time`에서 설정한 시간 이상 소요된 쿼리가 모두 기록된다.
- MySQL이 쿼리를 실행한 후, 실제 소요된 시간을 기준으로 판단한다.
- 따라서 쿼리가 일단 정상적으로 실행이 완료됐고 걸린 시간이 `long_query_time`에 정의된 시간보다 많이 걸린 쿼리인 것이다.
- InnoDB의 경우 MySQL 엕진 레벨의 잠금과 스토리지 엔진 자체 잠금을 가지고 있다.
- `Lock_time`이 InnoDB 테이블에 대한 것이 아니라 MySQL 엔진 레벨에서 설정한 잠금일 가능성이 있다.
- 따라서 InnoDB 테이블에만 접근하는 쿼리 문장의 슬로우 쿼리 로그에서는 `Lock_time` 값은 별로 도움이 되지 않는다.

# 5. 트랜잭션과 잠금
## 트랜잭션
### MySQL에서의 트랜잭션
- InnoDB는 쿼리 중 일부라도 오류가 발생하면 전체를 원래 상태로 만든다. 이와 달리, MyISAM은 오류가 난 데이터만 반영하지 않는다.

### 주의사항
- 프로그램 코드에서 트랜잭션의 범위를 최소화하는 것이 좋다.
- DBMS의 데이터를 저장하거나 변경하는 작업 외에는 트랜잭션에 포함하지 않는 게 좋다.
- 특히, 네트워크로 통신이 필요한 작업을 더욱 포함하지 않는 게 좋다.
- 또한 서로 다른 성격의 작업도 같은 트랜잭션으로 묶을 필요가 없다.
- 커넥션은 DBMS와 관련없는 작업을 수행한 후, 필요할 때 얻어서 바로 DBMS 작업을 처리하는 게 좋다.

## MySQL 엔진의 잠금
- MySQL에서 사용되는 잠금은 스토리지 엔진 레벨과 MySQL 엔진 레벨로 나눌 수 있다.
- MySQL 엔진 레벨의 잠금은 모든 스토리지 엔진에 영향을 미치지만, 스토리지 엔진 레벨의 잠금은 스토리지 엔진 간 상호 영향을 미치지 않는다.

### 글로벌 락
- MySQL에서 제공하는 잠금 가운데 가장 범위가 크다.
- 한 세션에서 글로벌 락을 획득하면 다른 세션에서 DDL 문장을 실행하는 경우 글로벌 락이 해제될 때까지 해당 문장이 대기 상태로 남는다.
- 영향을 미치는 범위는 MySQL 서버 전체이다.
- 명령을 실행하는 동시에 MySQL 서버에 존재하는 모든 테이블을 닫고 잠금을 건다.
- 가급적 웹 서비스 용으로 사용되는 MySQL 서버에는 사용하지 않는 게 좋다.
- `mysqldump` 같은 백업 프로그램은 내부적으로 이 명령을 내부적으로 실행하고 백업할 때도 있다.
- 이를 이용하면 사용하는 옵션에 따라 어떤 잠금을 걸게 되는지 자세히 확인해보는 게 좋다.
- MySQL 8.0 버전부터는 백업 툴들의 안정적인 실행을 위해 백업 락이 도입됐다.
- 백업 락은 정상적으로 복제는 실행되지만 백업의 실패를 막기 위해 DDL 명령이 실행되면 복제를 일시 중지하는 역할을 한다.

### 테이블 락
- 명시적 또는 묵시적으로 특정 테이블의 락을 획득할 수 있다.
- 묵시적인 테이블 락은 MyISAM이나 MEMORY 테이블에 데이터를 변경하는 쿼리를 실행하면 발생한다.
- 하지만 InnoDB 테이블은 스토리지 엔진 차원에서 레코드 기반의 잠금을 제공한다.
- 따라서 데이터 변경으로 묵시적 테이블 락이 설정되지는 않는다.
- 대부분의 데이터 변경(DML) 쿼리에서는 무시되고 스키마를 변경하는 쿼리(DDL)의 경우에만 영향을 미친다.

### 네임드 락
- 임의의 문자열에 대해 잠금을 설정할 수 있다.
- 웹 서버간 정보 동기화, 복잡한 요건으로 레코드를 변경하는 트랜잭션, 배치 프로그램에서 유용하게 사용할 수 있다.

### 메타데이터 락
- 데이터베이스 객체(테이블, 뷰)의 이름이나 구조를 변경하는 경우에 획득하는 잠금이다.
- 명시적으로 획득하거나 해제할 수 있는 게 아니라 자동으로 획득하는 잠금이다.

## InnoDB 스토리지 엔진 잠금
- 스토리지 엔진 내부에서 레코드 기반의 잠금 방식을 탑재하고 있다.
- `information_schema` 데이터 베이스에 존재하는 `INNODB_TRX`, `INNODB_LOCKS`, `INNODB_LOCK_WAITS`라는 테이블을 조인해서 조회하면 관련 정보를 얻을 수 있다.

### InnoDB 스토리지 엔진의 잠금
- 레코드 락이 페이지 락으로, 또는 테이블 락으로 레벨업되는 경우는 없다.

#### 레코드 락
- 레코드 자체만을 잠그는 것을 레코드 락이라고 한다.
- 한 가지 중요한 차이는 InnoDB 스토리지 엔진은 레코드 자체가 아니라 인덱스의 레코드를 잠근다는 것이다.

#### 갭 락
- 레코드 자체가 아니라 레코드와 바로 인접한 레코드 사이의 간격만을 잠그는 것을 의미한다.
- 갭 락의 역할은 레코드와 레코드 사이의 간격에 새로운 레코드가 생성(INSERT) 되는 것을 제어하는 것이다.
- 자체보다는 넥스트 키 락의 일부로 자주 사용된다.

#### 넥스트 키 락
- 레코드 락과 갭 락을 합쳐 놓은 형태의 잠금.
- `STATEMENT` 포맷의 바이너리 로그를 사용하는 MySQL 서버에서는 `REPEATABLE READ` 격리 수준을 사용해야한다.
- 갭 락이나 넥스트 키 락은 바이너리 로그에 기록되는 쿼리가 레플리카 서버에서 실행될 때 소스 서버에서 만들어 낸 결과와 동일한 결과를 만들어내도록 보장하는 것이 주목적이다. 
- 하지만 이로인해 데드락이나 다른 트랜잭션이 기다릴 수도 있다.
- 가능하다면 바이너리 로그 포맷을 ROW 형태로 바꿔서 넥스트 키 락이나 갭 락을 줄이는 것이 좋다.
- MySQL 8.0에서 ROW 포맷이 기본 값이 됐다.

#### 자동 증가 락
- `AUTO_INCREMENT` 칼럼이 사용된 테이블에 여러 레코드가 INSERT 되는 경우 내부적으로 `AUTO_INCREMENT`락이라고 하는 테이블 수준의 잠금을 사용한다.
- 해당 락은 `INSERT`, `REPLACE` 같이 새로운 레코드를 저장하는 쿼리에서만 필요하며, `UPDATE`, `DELETE` 등의 쿼리에서는 걸리지 않는다.
- 아주 짧은 시간 동안 걸렸다가 해제돼서 대부분 문제가 되지 않는다.

### 인덱스와 잠금
- InnoDB의 잠금은 레코드를 잠그는 것이 아니라 인덱스를 잠그는 방식으로 처리된다.
- 예를 들어 다음과 같다고 해보자.
  - `employees` 테이블에는 `first_name` 컬럼으로만 인덱스가 만들어져있다.
  - `first_name='Georgi'`인 사원은 전체 253명, `last_name='Klassen'`인 사원은 1명이 있다.
  - 이때 'Klassen Georgi'를 업데이트 한다고 해보자.
  - 1건의 레코드만 업데이트 되더라도 `last_name` 인덱스가 없기 때문에 `first_name='Georgi'`인 레코드가 모두 잠김다.
- 만약 인덱스가 하나도 없다면 풀 스캔을 하기 때문에 모든 레코드가 잠기게 된다.

### 레코드 수준의 잠금 확인 및 해제
- 레코드 수준의 잠금은 테이블의 레코드 각각에 잠금이 걸린다.
- 그 레코드가 자주 사용되지 않는다면 오랜 시간 동안 잠겨진 상태로 남아 있어도 잘 발견되지 않는다.
- MySQL 5.1부터는 레코드 잠금과 잠금 대기에 대한 조회가 가능하다.
- 강제로 잠금을 해제하려면 `KILL` 명령을 이용해 강제 종료하면 된다.
- `SHOW PROCESSLIST`로 각 스레드(트랜잭션)의 상태를 볼 수 있다.
- 더 자세하게 보고 싶다면 `SELECT * FROM performance_schema.data_locks`를 보면 된다.

## MySQL의 격리 수준
- `SERIALIZABLE` 격리 수준이 아니라면 크게 성능 개선이나 저하는 발생하지 않는다.

|     | DIRTY READ | NON-REPEATABLE READ | PHANTOM READ |
| --- | --- | --- | --- |
| READ UNCOMMITED | 발생 | 발생 | 발생 |
| READ COMMITED | 없음 | 발생 | 발생 |
| REAPEATABLE READ | 없음 | 없음 | 발생(InnoDB X) |
| SERIALIZABLE | 없음 | 없음 | 없음 |

- 일반적인 온라인 서비스 용도의 데이터 베이스는 MySQL에서는 `REPEATABLE READ`를 주로 사용한다.

### READ UNCOMMITED
- 각 트랜잭션에서의 변경 내용이 `COMMIT`이나 `ROLLBACK` 여부와 상관없이 다른 트랜잭션에서 보인다.
- 이런 현상을 더티 리드라고한다.
- MySQL을 사용한다면 최소환 `READ COMMITED` 이상의 격리 수준을 사용할 것을 권장한다.

### READ COMMITED
- 온라인 서비스에서 가장 많이 선택되는 격리 수준이다.
- 커밋 전에는 다른 트랜잭션에서 언두 영억의 백업된 레코드에서 가져온다.
- NON-REPEATABLE READ가 발생할 수 있다.
- 금전적인 트랜잭션에서는 조심해야한다.

### REPEATABLE READ
- InnoDB 스토리지 엔진에서 기본으로 사용되는 격리수준이다.
- 바이너리 로그를 가진 MySQL 서버에서는 최소 `REPEATABLE READ` 격리 수준 이상을 사용해야한다.
- 이 격리 수준에서는 `NON-REPEATABLE READ` 부정합이 발생하지 않는다.
- `REPEATABLE READ`는 MVCC를 위해 언두 영역에 백업된 이전 데이터를 이용해 동일 트랜잭션 내에서 동일한 결과를 보여줄 수 있게 보장한다.
- `REPEATABLE READ`와 `READ COMMITED`의 차이는 언두 영역에 백업된 레코드의 여러 버전 가운데 몇 번째 이전 버전까지 찾아 들어가야 하느냐에 있다.
- 모든 InnoDB 트랜잭션은 고유한 트랜잭션 번호를 가진다.
- 언두 영역에 백업된 모든 레코드에는 변경을 발생시킨 트랜잭션의 번호가 포함돼있다.
- 언두 영역의 백업된 데이터는 InnoDB 스토리지 엔진이 불필요하다고 판단하는 시점에 주기적으로 삭제한다.
- 트랜잭션 번호가 자신보다 작은 트랜잭션에서 변경한 것만 보게 된다.
- 그래서 장시간 트랜잭션을 종료하지 않으면 언두 영역이 백업된 데이터로 무한정 커질 수 있다.
- 다른 트랜잭션에서 수행한 변경 작업에 의해 레코드가 보였다 안 보였다 하는 현상을 PHANTOM READ라고 한다. (주로 새로 추가된 로우에 의해 발생)
- `SELECT ... FOR UPDATE`는 레코드에 쓰기 잠금을 걸 수는 있지만 언두 레코드에는 잠금을 걸 수 없다.

### SERIALIZABLE
- 가장 엄격한 격리 수준이어서 그만큼 동시 처리 성능도 다른 트랜잭션 격리 수준보다 떨어진다.
- 읽기 작업도 공유 잠금을 획득해야한다.
- 하지만 InnoDB 스토리지 엔진에서는 갭 락과 넥스트 키 락 덕분에 `REPEATABLE READ` 격리 수준에서도 팬텀 리드가 발생하지 않는다.
- [이미지 참고](https://letmecompile.s3.amazonaws.com/wp/wp-content/uploads/2018/06/next_key_lock.png)
  - 다른 예시, https://stackoverflow.com/a/57343438
  - Lock을 광범위하게 잡아버리면 gap lock과 record lock(on the index record)이 합쳐진 next-key lock으로 무시무시한 락이 걸려버린다.

## 8. 인덱스
## 디스크 읽기 방식
### HDD와 SSD
- 순차 I/O에서는 비슷할 수도 있지만 랜덤 I/O가 훨씬 빠르다.
- 데이터 베이스 서버에서 순차 I/O 작업은 그다지 비중이 크지 않고 랜덤 I/O를 통해 작은 데이터를 읽고 쓰는 작업이 대부분이다.
- SSD의 장점은 DBMS용 스토리지에 최적이다.

### 랜덤 I/O와 순차 I/O
- 순차 I/O는 랜덤 I/O보다 디스크 기록을 위한 시스템 콜 횟수가 더 적다.
- 쿼리를 튜닝하는 것은 랜덤 I/O 자체를 줄여주는 게 목적이다. 즉, 쿼리를 처리하는 데 꼭 필요한 데이터만 읽도록 쿼리를 개선하는 것을 의미한다.

## 인덱스란?
- DBMS의 인덱스도 마찬가지로 컬럼의 값을 주어진 순서로 미리 정렬해서 보관한다.
- DBMS에서 인덱스는 데이터의 저장(INSERT, UPDATE, DELETE) 성능을 희생하고 데이터 읽기 속도를 높이는 기능이다.
- 프라이머리 키는 NULL 값을 허용하지 않으며 중복을 허용하지 않는 것이 특징이다.
- 프라이머리 키를 제외한 나머지 모든 인덱스는 세컨더리 인덱스로 분류한다.
- 데이터 중복 허용 여부로 분류하면 유니크 인덱스와 유니크하지 않은 인덱스로 구분할 수 있다.
- 옵티마이저에게는 중요한 문제가 된다.
