## 4.아키텍처
### MySQL 스레딩 구조
- InnoDB를 사용할 경우, 포그라운드 스레드와 백그라운드 스레드를 사용한다.
- 포그라운드 스레드는 클라이언트가 요청하는 쿼리 문장을 처리한다.
- 백그라운드 스레드는 버퍼 병합, 로그 디스크 기록, 버퍼로 읽어오기, 잠금이나 데드락 모니터링등을 수행한다.

#### 백그라운드 스레드
- 쓰기 스레드는 많은 작업을 백그라운드로 처리한다.
- 일반적인 내장 디스크를 사용할 때는 2~4 정도, DAS나 SAN과 같은 스토리지는 최적으로 사용할만큼 충분히 하는 게 좋다.
- 대부분의 DBMS는 쓰기 작업을 버퍼링해 처리한다.
- InnoDB도 이렇게 처리하지만 MyISAM은 그렇지 않다.

### 메모리 할당 및 사용 구조
- MySQL에서 사용되는 메모리 공간은 글로벌 메모리 영역과 로컬 메모리 영역으로 구분할 수 있다.

#### 글로벌 메모리 영역
- 모든 스레드에 의해 공유된다.
- 클라이언트 스레드 수와 무관하다.
- 대표적으로 다음과 같다.
  - 테이블 캐시
  - InnoDB 버퍼 풀
  - InnoDB 어댑티브 해시 인덱스
  - InnoDB 리두 로그 버퍼

#### 로컬 메모리 영역
- called 세션 메모리 영역 -> 클라이언트와 MySQL 서버와의 커넥션을 세션이라고 하기 때문에
- MySQL 서버상에 존재하는 클라이언트 스레드가 쿼리를 처리하는데 사용하는 메모리 영역이다.
- 클라이언트 스레드끼리 절대 공유하지 않는다.
- 각 쿼리의 용도별로 필요할 때만 할당하고 필요하지 않은 경우 할당을 하지 않는다.
- 대표적으로 다음과 같다.
  - 정렬 버퍼
  - 조인 버퍼
  - 바이너리 로그 캐시
  - 네트워크 버퍼

#### 플러그인 스토리지 엔진 모델
- 데이터 읽기 및 쓰기는 스토리지 엔진에서 처리되고 나머지 작업은 MySQL 엔진에서 처리된다.
- MySQL 엔진은 스토리지 엔진을 조정하기 위해 핸들러를 이용한다.
- 스토리지 엔진에게 데이터를 읽어오거나 저장하도록 명령하려면 반드시 핸드러를 통해야한다.
- GROUP BY나 ORDER BY 등 복잡한 처리는 MySQL 엔진의 쿼리 실행기에서 처리된다.

### 쿼리 실행 구조
- SQL 요청 -> 쿼리 파서 -> 전처리기 -> 옵티마이저 -> 쿼리 실행기 -> 스토리지 엔진 -> SQL 결과

#### 쿼리 파서
- 쿼리를 토큰으로 분리해 트리 형태의 구조로 만들어낸다.
- 기본 문법 오류는 이때 발견된다.

#### 전처리기
- 각 토큰을 테이블 이름이나 컬럼 이름 같은 개체에 매핑해 해당 객체의 존재 여부등을 확인한다.

#### 옵티마이저
- 쿼리를 저렴한 비용으로 가장 빠르게 처리하는 방법을 결정한다.
- 중요하고 영향 범위가 넓다.

#### 실행 엔진
- 만들어진 계획대로 각 핸들러에게 요청한다.
- 핸들러에게 받은 결과를 또 다른 핸들러 요청의 입력으로 연결한다.

#### 핸들러(스토리지 엔진)
- MySQL 서버 가장 밑단에서 실행 엔진의 요청에 따라 데이터를 디스크로 저장하고 디스크로부터 읽어 오는 역할을 담당한다.
- 결국 스토리지 엔진을 의미한다.

### 쿼리 캐시
- 쿼리 실행 결과를 메모리에 캐시해 읽기 성능에 큰 도움을 줬다.
- 하지만, 동시 처리 성능 저하와 많은 버그의 원인이 됐다.
- 그래서 8.0에서는 제거됐다.

### 스레드 풀
- 기본적으로 엔터프라이즈 에디션에서만 제공하고 커뮤니티 에디션은 지원하지 않는다.
- 대신 Percona Server에서 스레드 풀 기능을 제공한다.
- 플러그인 형태로 사용할 수 있다.
- 스레드 풀은 사용자의 요청을 처리하는 스레드 개수를 줄여 동시 처리되는 요청이 많더라도, CPU가 제한된 개수의 스레드 처리에만 집중하게 해 서버 자원의 소모를 줄이는 것이 목적이다.
- 설치한다고 성능이 두 배가 되고 그런 건 아니다.
- Percona Server의 스레드 풀은 기본적으로 CPU 코아 개수만큼 스레드 그룹을 생성한다.
- CPU 코어의 개수와 스레드 그룹 개수를 맞추는게 CPU 프로세스 친화도를 높이는 데 좋다.
- 스레드 풀은 스레드 그룹의 모든 스레드가 일을 처리하고 있다면, 새로운 작업 스레드를 추가할지 아니면 기존 작업 스레드가 처리를 완료할 때까지 기다릴지를 판단해야한다.
- 타이머 스레드는 스레드 그룹의 상태를 체크해서 `thread_pool_stall_limit` 시스템 변수에 정의된 밀리초만큼 끝내지 못하면 새로운 스레드를 생성한다.
- 하지만 전체 스레드 개수는 `thread_pool_max_threads`를 넘길 수 없다.
- 응답 시간에 민감한 서비스라면 `thread_pool_max_threads`을 적절히 낮춰야한다.

#### 트랜잭션 지원 메타데이터
- 테이블 구조 정보와 스토어드 프로그램 등의 정보를 데이터 딕셔너리 또는 메타데이터라고 한다.
- 8.0 이전 버전에서는 파일로 저장했지만 문제가 있어, 8.0 부터는 InnoDB의 테이블에 저장하도록 개선됐다.
- mysql DB는 `mysql.ibd`라는 이름의 테이블스페이스에 저장된다.
- 데이터 딕셔너리와 시스템 테이블이 모두 트랜잭션 기반의 InnoDB 스토리지 엔진에 저장되도록 개선됐다.
- 그래서 스키마 변경 작업 중간에 MySQL 서버가 비정상적으로 종료된다고 하더라도 스키마 변경이 완전히 성공하거나 완전히 실패로 정리된다.
- InnoDB 이외의 엔진은 SDI 파일을 이용한다.
- `*.ibd`를 `ibd2sdi`를 이용해 json으로 덤프할 수 있다.

## InnoDB 스토리지 엔진 아키텍처
- 스토리지 엔진 중 거의 유일하게 레코드 기반의 잠금을 제공한다.
- 그래서 높은 동시성 처리가 가능하고 안정적이며 성능이 뛰어나다.

### 프라이머리 키에 의한 클러스터링
- InnoDB의 모든 테이블은 기본적으로 프라이머리 키를 기준으로 클러스터링돼 저장된다.
- 프라이머리 키 값의 순서대로 디스크에 저장된다.
- 모든 세컨더리 인덱스는 레코드 주소 대신 프라이머리 키의 값을 논리적인 주소로 사용한다.
- 클러스터링 인덱스이기 때문에 프라이머리 키를 이용한 레인지 스캔은 상당히 빨리 처리될 수 있다.
- 쿼리 실행 계획에서 다른 보조 인덱스에 비해 비중이 높게 설정된다.

### 외래 키 지원
- InnoDB에서 외래 키는 부모 테이블과 자식 테이블 모두 해당 컬럼에 인덱스 생성이 필요하다.
- 변경 시에 부모 테이블이나 자식 테이블에 데이터가 있는지 체크하는 작업이 필요하므로 잠금이 여러 테이블로 전파된다.
- 따라서 데드락이 발생할 때가 많다.
- `foreign_key_checks` 시스템 변수를 `OFF`로 설정하면 외래 키 관계에 대한 체크 작업을 일시적으로 멈출 수 있다.
- 대량 레코드 적재나 삭제 등의 작업도 체크 없이 훨씬 빠르게 처리할 수 있다.
- 단, 작업 후 반드시 `ON`으로 다시 켜야한다.

### MVCC(Multi Version Concurrency Control)
- 레코드 레벨의 트랜잭션을 지원하는 DBMS가 제공하는 기능이다.
- 가장 큰 목적은 잠금을 사용하지 않는 일관된 읽기를 제공하는 데 있다.
- InnoDB는 undo log를 이용해 구현한다.
- 업데이트를 할 때, InnoDB 버퍼 풀에 새운 값을 업데이트하고 unndo log에 이전 값을 기록해둔다.
- 디스크인 데이터 파일에는 Write 스레드에 의해 새로운 값으로 업데이트 됐을 수도 있다.
- 다른 트랜잭션에서 해당 레코드를 조회하면 isolation level에 따라 다른 값을 조회한다.
- `READ_UNCOMMITED`인 경우 버퍼 풀의 데이터를 읽고 `READ_COMMITED` 이상은 언두에 있는 걸 읽는다.
- 이런 과정은 MVCC라고 한다.
- 트랜잭션이 길어지면 언두에서 오랫 동안 관리해야하기 때문에 시스템 테이블 스페이스의 공간이 많이 늘어날 수도 있다.
- 커밋을 수행하면 변경된 상태를 영구적으로 만든다.
- 롤백을 수행하면 언두 영역에 있는 걸 다시 버퍼 풀로 복구하고 언두 내용을 삭제한다.
- 커밋이 됐을 때 언두 영역의 백업 데이터가 바로 삭제되는 게 아니라 해당 트랜잭션이 더는 없을 때 삭제된다.

#### Non-Locking Consistent Read
- InnoDB 엔진은 MVCC 기술을 이용해 잠금을 걸지 않고 읽기 작업을 수행한다.
- 읽기 작업은 다른 트랜잭션이 가지고 있는 잠금을 기다리지 않고, 읽기 작업이 가능하다.
- isolation level이 `SERIALIZABLE` 미만이면 순수한 읽기(`SELECT`) 작업은 다른 트랜잭션의 변경 작업과 관계없이 잠금 대기없이 바로 실행된다.
- 트랜잭션이 오랫 동안 활성 상태라면 일관된 읽기를 위해 언두 로그를 삭제하지 못하고 계속 유지해야 하기 때문에 문제가 발생할 수 있다.

#### 자동 데드락 감지
- InnoDB 엔진은 데드락 감지 스레드를 가지고 있다.
- 데드락 감지 스레드가 주기적으로 잠금 대기 그래프를 검사해 교착 상태에 빠진 트랜잭션들을 찾아서 그 중 하나를 강제 종료한다.
- 먼저 종료할 스레드를 판단하는 기준은 트랜잭션의 언두 로그 양이다.
- 언두 로그 양이 적을 수록 종료 우선 순위가 높다.
- `innodb_table_locks` 시스템 변수를 활성화하면 InnoDB 스토리지 엔진 내부의 레코드 잠금뿐만 아니라 테이블 레벨의 잠금까지 감지할 수 있게 된다. 그래서 활성화하는 게 좋다.
- 동시 처리 스레드가 많아지만 데드락 감지 스레드가 느려진다.
- 느려지면 서비스 쿼리를 처리 중인 스레드는 대기하면서 서비스에 영향을 끼친다. 또한 데드락 감지 스레드가 더 많은 CPU 자원을 소모할 수도 있다.
- 이런 문제점을 위해 MySQL 서버는 `innodb_deadlock_detect` 시스템 변수를 제공한다.
- `OFF`로 설정하면 데드락 감지 스레드가 더는 작동하지 않는다.
- 이렇게 되면 데드락이 발생해도 무한정 대기할 수도 있다.
- `innodb_lock_wait_timeout` 시스템 변수를 활성화하면 데드락 상황에서 일정 시간이 지나면 자동으로 요청이 실패하고 에러 메세지를 반환한다.
- 잠금을 설정한 시간 동안 획득하지 못하면 쿼리를 실패하고 에러를 반환한다.
- 이 시간은 기본값인 50초 보다 낮은 시간으로 변경해서 사용할 것을 권장한다.

#### 자동화된 장애 복구
- InnoDB는 MySQL 서버가 시작될 때 완료되지 못한 트랜잭션이나 디스크에 일부만 기록된 데이터 페이지 등에 대해 복구 작업이 자동으로 진행된다.
- 자동으로 복구될 수 없는 손상이 있다면 자동 복구를 멈추고 MySQL 서버가 종료된다.
- 이때는 `MySQL` 서버의 설정 파일에 `innodb_force_recovery` 시스템 변수를 설정해서 MySQL 서버를 시작해야한다.
