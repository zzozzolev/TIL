## 트랜잭션 매니저와 트랜잭션 동기화 매니저 동작 방식
1. 서비스 계층에서 `transactionManager.getTransaction()`을 호출해서 트랜잭션을 시작한다.
2. 트랜잭션을 시작하려면 먼저 데이터베이스 커넥션이 필요하다. 트랜잭션 매니저는 내부에서 데이터소스를 사용해서 커넥션을 생성한다.
3. 커넥션을 수동 커밋 모드로 변경해서 실제 데이터베이스 트랜잭션을 시작한다.
4. 커넥션을 트랜잭션 동기화 매니저에 보관한다.
5. 트랜잭션 동기화 매니저는 쓰레드 로컬에 커넥션을 보관한다. 따라서 멀티 쓰레드 환경에 안전하게 커넥션을 보관할 수 있다.
6. 서비스는 비즈니스 로직을 실행하면서 레포의 메서드들을 호출한다. 이때 커넥션을 파라미터로 전달하지 않는다.
7. 레포 메서드들은 트랜잭션이 시작된 커넥션이 필요하다. 레포는 `DataSourceUtils.getConnection()`을 사용해서 트랜잭션 동기화 매니저에 보관된 커넥션을 꺼내서 사용한다. 이 과정을 통해서 자연스럽게 같은 커넥션을 사용하고, 트랜잭션도 유지된다.
8. 획득한 커넥션을 사용해서 SQL을 데이터베이스에 전달해서 실행한다.
9. 비즈니스 로직이 끝나고 트랜잭션을 종료한다. 트랜잭션은 커밋하거나 롤백하면 종료된다.
10. 트랜잭션을 종료하려면 동기화된 커넥션이 필요하다. 트랜잭션 동기화 매니저를 통해 동기화된 커넥션을 획득한다.
11. 획득한 커넥션을 통해 데이터베이스에 트랜잭션을 커밋하거나 롤백한다.
12. 전체 리소스를 정리한다.
  - 트랜잭션 동기화 매니저를 정리한다. 쓰레드 로컬은 사용후 꼭 정리해야한다.
  - 오토 커밋을 true로 되돌린다. 커넥션 풀을 고려해야한다.
  - `conn.close()`를 호출해 커넥션을 종료한다. 커넥션 풀을 사용하는 경우 커넥션 풀에 반환된다.

## 트랜잭션 AOP 적용 전체 흐름
1. 프록시 호출
2. 스프링 컨테이너를 통해 트랜잭션 매니저 획득
3. 트랜잭션 매니저를 통해 트랜잭션 획득 (`transactionManager.getTransaction()`)
4. 데이터소스 -> 커넥션 생성
5. 커넥션 오토커밋 false 설정
6. 트랜잭션 동기화 매니저에 커넥션 보관
7. 보관된 커넥션
8. 실제 서비스 호출
9. 트랜잭션 동기화 커넥션 획득

## 트랜잭션 AOP 주의 사항
### 프록시 내부 호출
- `@Transactional`을 적용하면 프록시 객체가 요청을 먼저 받아서 트랜잭션을 처리하고, 실제 객체를 호출해준다.
- AOP를 적용하면 스프링은 대상 객체 대신에 프록시를 스프링 빈으로 등록한다.
- 대상 객체의 내부에서 메서드 호출이 발생하면 프록시를 거치지 않고 대상 객체를 직접 호출해 트랜잭션이 적용되지 않는 문제가 발생한다.
- 원인은 자바에서 별도 참조가 없으면 `this`는 자신의 인스턴스를 가리킨다.
- 결국 자신의 메서드, 즉 원래 인스턴스의 메서드를 뜻한다. 그래서 프록시를 거치지 않아 트랜잭션을 적용할 수 없다.
- 해결 방법은 여러 가지가 있으나 복잡하지 않은 방법은 내부 메서드 호출을 외부 클래스의 메서드 호출로 바꾸는 것이다.

### public 메서드만 트랜잭션 적용
- 스프링의 트랜잭션 AOP 기능은 `public` 메서드에만 트랜잭션을 적용하도록 기본 설정이 돼있다.
- 그래서 `protected`, `private`, `package-visibile`에는 트랜잭션이 적용되지 않는다.
- 클래스 레벨에 트랜잭션을 적용하면 모든 메서드에 트랜잭션이 걸릴 수 있다. 그러면 트랜잭션을 의도하지 않는 곳까지 트랜잭션이 과도하게 적용된다.
- 트랜잭션은 주로 비즈니스 로직의 시작점에 걸기 때문에 대부분 외부에 열어준 곳을 시작점으로 사용한다.
- `public`이 아닌 곳에 `@Transactional`이 붙어 있으면 예외가 발생하지 않고 트랜잭션 적용만 무시된다.

### 초기화 시점
- 스프링 초기화 시점에는 트랜잭션 AOP가 적용되지 않을 수 있다.
- 초기화 코드(ex: `@PostConstruct`)와 `@Transactional`을 함께 사용하면 트랜잭션이 적용되지 않는다.
- 왜냐하면 초기화 코드가 먼저 호출되고 그 다음에 트랜잭션 AOP가 적용되기 때문이다.
- 따라서 초기화 시점에는 해당 메서드에서 트랜잭션을 획득할 수 없다.
- 대안은 `ApplicationReadyEvent` 이벤트를 사용하는 것이다.

## 트랜잭션 옵션
### `rollbackFor`, `noRollbackFor`
- 예외 발생시 스프링 트랜잭션의 기본 정책은 다음과 같다.
- 언체크 예외인 `RuntimeException`, `Error`와 그 하위 예외가 발생하면 롤백한다.
- 체크 예외인 `Exception`과 그 하위 예외들은 커밋한다.
- 이 옵션을 사용하면 기본 정책에 추가로 어떤 예외가 발생할 때 롤백할 지 지정할 수 있다.
- `noRollbackFor`는 반대이다.

### `timeout`
- 트랜잭션 수행 시간에 대한 타임아웃을 초 단위로 지정한다.
- 기본 값은 트랜잭션 시스템의 타임아웃을 사용한다.
- 운영 환경에 따라 동작하는 경우도 있꼬 그렇지 않은 경우도 있기 때문에 꼭 확인하고 사용해야한다.

### `readOnly`
- 트랜잭션은 기본적으로 읽기 쓰기가 모두 가능한 트랜잭션이 생성된다.
- `readOnly=true` 옵션을 사용하면 읽기 전용 트랜잭션이 생성된다. 이 경우 insert, update, delete가 안되고 읽기 기능만 작동한다.
- 그리고 일긱에서 다양한 성능 최적화가 발생할 수 있다.
- `readOnly` 옵션은 크게 3곳에서 적용된다.

1. 프레임워크
    - `JdbcTemplate`은 읽기 전용 트랜잭션 안에서 변경 기능을 실행하면 예외를 던진다.
    - JPA는 읽기 전용 트랜잭션의 경우 커밋 시점에 flush를 호출하지 않는다.
    - 읽기 전용이니 변경에 사용되는 flush를 호출할 필요가 없다.
    - 추가로 변경이 필요 없으니 변경 감지를 위한 스냅샷 객체도 생성하지 않는다.
2. JDBC 드라이버
    - DB와 드라이버 버전에 따라서 다르게 동작하기 때문에 사전에 확인이 필요하다.
    - 읽기 전용 트랜잭션에서 변경 쿼리가 발생하면 예외를 던진다.
    - 마스터, 슬레이브 데이터 베이스를 구분해서 요청한다. 읽기 전용 트랜잭션의 경우 슬레이브 데이터베이스의 커넥션을 획득해서 사용한다. (MySQL)
3. 데이터베이스
    - 데이터베이스에 따라 읽기 전용 트랜잭션의 경우 읽기만 하면 되므로, 내부에서 성능 최적화가 발생한다.
