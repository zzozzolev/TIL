# Transaction
- https://docs.djangoproject.com/ko/3.2/topics/db/transactions/

## Django’s default transaction behavior¶
- 장고의 기본 전략은 오토 커밋 모드로 실행하는 것이다.
- 트랜잭션이 active 하지 않다면 각각의 쿼리는 즉시 커밋된다.
- 장고는 `delete()`, `update()` 쿼리와 같이 여러 쿼리를 요구하는 ORM의 인터그리티를 보장하기 위해 자동으로 트랜잭션과 세이브 포인트를 사용한다.

## Tying transactions to HTTP requests
- 웹에서 트랜잭션을 다루는 흔한 방법은 트랜잭션에 각각의 리퀘스트 감싸는 것이다.
- 만약 이런 행동을 원한다면 database 설정에서 `ATOMIC_REQUESTS`를 `True`로 하면 된다. (`False`가 디폴트임)
- 다음과 같이 작동한다. view 함수를 부르기 전에 장고는 트랜잭션을 시작한다. 만약 응답이 문제 없이 생성된다면, 장고는 트랜잭션을 커밋한다. 만약 예외가 발생한다면 장고는 트랜잭션을 롤백한다.
- view 코드에서 subtracsactions를 수행할 수도 있는데 보통 `atomic` 매니저를 이용한다.
- 하지만 view의 끝에서 변경 사항들이 전부 커밋되거나 전부 커밋되지 않는다.
- 이렇게하면 간단하기는 하지만 트래픽이 올라갔을 때 비효율적이게 된다. 모든 뷰마다 트랜잭션을 여는 것은 약간의 오버헤드가 있기 때문이다.
- 퍼포먼스에 대한 영향을 앱의 쿼리 패턴과 얼마나 잘 데이터 베이스 락킹을 잘 다루냐에 있다.
- 주의해야할 것은 뷰의 실행만 트랜잭션에 있는 것이고 미들웨어의 실행은 트랜잭션 밖에 잇는 것이다.

## Django에서 자동 커밋을 사용하는 이유
- SQL 표준들에서는 트랜잭션이 이미 active 하지 않다면, 각각의 SQL 쿼리는 트랜잭션을 시작한다.
- 그러한 트랜잭션들은 반드시 명시적으로 커밋되거나 롤백돼야한다.
- 앱 개발자들에게는 항상 이게 편리하지는 않다. 이 문제를 완화하기 위해서는 대부분의 데이터 베이스들을 오토 커밋 모드를 제공한다.
- 오토커밋이 켜져있고 트랜잭션이 active 하지 않다면 각각의 SQL 쿼리는 자신의 트랜잭션에 싸여져있다.
- 다시 말해서 각각의 그러한 쿼리는 트랜잭션을 시작할 뿐만 아니라 쿼리 성공 여부에 따라 자동적으로 커밋되거나 롤백된다.
- `PEP 249`에 따르면 파이썬 Database API 스펙 2.0에는 오토커밋이 처음에 꺼져있는 걸 요구하고 있다. 하지만 장고에서는 오버라이드해서 기본으로 켜져있다.
- 이렇게 하지 않기 위해서는 트랜잭션 관리를 끄면 되는데 추천하지는 않는다.

## 트랜잭션 관리 비활성화
- `AUTOCOMMIT`을 `False`로 하면 장고의 트랜잭션 관리를 디스에이블할 수도 있다.
- 그렇게 한다면 장고는 오토 커밋이 가능하게 하지 않고 어떤 커밋도 수행하지 않는다. 기본적인 데이터 베이스 라이브버리와 비슷하게 된다.
- 장고에 의해서 시작되든 third-party 라이브러리에서 시작되든 명시적으로 모든 트랜잭션을 커밋해야한다.

## 실제 코드로 테스트
- 수도 코드
```
Save User
Raise Error
Save Profile
```

| `ATOMIC_REQUESTS` | transaction manager | `@transaction.atomic` decorator | result |
| --- | --- | --- | --- |
| `False` | X | X | User 저장 |
| `True` | X | X | User 저장 X |
| `False` | O | X | User 저장 X |
| `False` | X | O | User 저장 X |
