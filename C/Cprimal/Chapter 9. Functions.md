- 그냥 character 하나 출력이면 `printf`보다 `putchar`를 쓰는 게 속도 상 더 좋음. 무조건은 아니지만 `printf`에서 char 하나 출력하는 건 `putchar`를 쓰는 듯
- argumenting list가 없는 게 older form. 예를 들면 `void func(void)` 이렇게 쓰는 게 아니라 `void func()` 이렇게 쓰는 거.
- 함수에 타입 잘못 넘겨주거나 개수 잘못 넘겨주면 대참사 발생 가능. 예를 들면 `func(int x, int y)` 으로 정의돼있으면 stack에서 64bit를 읽을 텐데 float을 넘겨준 경우 그 만큼 가져오지 않음.
- prototyping으로 `int imax(int, int);` 이렇게 쓸 수도 있고 `int imax(int a, int b);` 이렇게 쓸 수도 있는데 variable name은 dummy 이므로 타입만 써도 충분할 거 같다.
- prototyping을 해놓으면 type이 안 맞는 경우 알아서 바꿔줌. For example, `imax(3.0, 5.0)` becomes `imax(3, 5)` 근데 이것도 이거 나름대로 문제일 거 같다. 아 근데 warning을 준다고 함. 근데 vscode에서 해도 안 됨...
- `void print_name();` An ANSI C compiler will assume that you have decided to forego function prototyping, and it will not check arguments. To indicate that a function really has no arguments, use the void keyword within the parentheses
- function이 짧으면 그냥 위에다가 한번에 선언하는 방법도 있음
- it's good programming practice to place function prototypes and defined constants in a header file.
- header file은 상수나 prototype 정의해두는 곳. 나중에 한 파일에 있는 함수를 다른 파일에서도 쉽게 사용할 수 있음.
- 여러 파일 같이 컴파일할 때는 header file 빼고 source file만 넘겨주면 됨. 예를 들면 `hotel.c`, `usehotel.c`, `hotel.h`가 있다면 `gcc -o usehotel hotel.c usehotel.c` 이렇게 하면 됨. 여기서 header file 넘겨주면 `clang: error: cannot specify -o when generating multiple output files` 이런 에러 남.
- Each function uses its own variables.
- `&` is giving the adress of that variable and `*`(indirection) is finding the value it points to. The statements `ptr = &bah;` and `val = *ptr;` taken together amount to the following statement: `val = bah;`
- The type specification identifies the type of variable pointed to, and the asterisk (*) identifies the variable itself as a pointer. The declaration `int * pi;` says that `pi` is a pointer and that `*pi` is type int. But a pointer really is a new type, not an integer type.
- The space between the `*` and the pointer name is optional. Often, programmers use the space in a declaration and omit it when dereferencing a variable.
- prototype에 `void func(int * u, int * v)` 이런 식으로 pointer 넘겨줄 수도 있음.
- declaring two 305 variables of the same name in different functions creates two distinct variables. Also, one function does not have direct access to variables declared in another function. This limited access helps preserve data integrity. However, if you do need one function to access another function's data, you can use pointer function arguments.