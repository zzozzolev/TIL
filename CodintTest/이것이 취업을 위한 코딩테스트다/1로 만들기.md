### 소모 시간
- 13분 13초

### 접근법
- 인덱스로 수를 표현하고 `dp[i]`는 연산을 사용하는 횟수의 최솟값을 담도록한다.
- 만약 인덱스(수)가 3이나 5로 나누어진다면 `dp[i//3] + 1` 혹은 `dp[i//5] + 1`를 사용한다.
- `1을 뺀 수의 최솟값 + 1`, `dp[i//3] + 1`, `dp[i//5] + 1` 중 최솟값을 `dp[i]`로 설정한다.

### 문제점
- 2를 빼먹었다 ㅎㅎ;
- `min`을 모든 수를 대상으로 하지 않고 그때그때 조건에 따라 `min`을 하면 불필요한 `float(inf)`를 선언하지 않아도된다.
- 2부터 바로 반복문을 돌아도 된다.

### my solution
```
n = 26

dp = [0] * (n + 1)
dp[2] = 1
dp[3] = 1
dp[4] = 2
dp[5] = 1

for i in range(6, n + 1):
    three = dp[i//3] + 1 if i % 3 == 0 else float("inf")
    five = dp[i//5] + 1 if i % 5 == 0 else float("inf")
    dp[i] = min(dp[i - 1] + 1, three, five)

print(dp[n])
```