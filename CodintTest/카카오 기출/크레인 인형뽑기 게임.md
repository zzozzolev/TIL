### 소요 시간
- 45분

### 통과율
- 100%

### 접근법
- 뽑은 인형을 저장할 `bucket`이라는 변수를 초기화한다.
- `moves`의 원소를 순회하면서 다음의 과정을 반복한다.
- `col`이라는 변수에 `loc - 1`을 저장한다.
- `board`를 순회하면서 `col`번째 값이 `0`이 아니라면 `idx`라는 변수에 몇 번 째 층인지 저장한다.
- `idx`가 초기값이거나 `board[idx][col] == 0`이면 continue
- `bucket`의 마지막 값과 `board[idx][col]`이 같다면 `bucket`에서 마지막 원소를 제거한 후 `answer`에 2를 더해준다.
- `bucket`의 마지막 값과 `board[idx][col]`이 다르다면 `bucket`에 `board[idx][col]`을 추가한다.
- `board[idx][col]`에 0을 대입해 빈공간으로 만들어준다.

### 문제점
- `boards`의 리스트를 row가 아닌 col로 이해해 잘못 풀었다. 즉 문제를 제대로 이해하지 않았다.

### my solution
```
def solution(board, moves):
    answer = 0
    bucket = []
    
    for loc in moves:
        col = loc - 1
        idx = -1
        
        for row, values in enumerate(board):
            if values[col] != 0:
                idx = row
                break
        
        # skip empty board
        if idx == -1 or board[idx][col] == 0:
            continue
        else:
            if len(bucket) > 0 and board[idx][col] == bucket[-1]:
                bucket.pop()
                answer += 2
            else:
                bucket.append(board[idx][col])
            board[idx][col] = 0
        
    return answer
```

### other solution